# 类

> 类相当于一个特征模板,而对象则是类特征的拷贝,并且独立于其他对象来操作这些特征。但是,在某些情况下,我们需要某些特征被所有的对象实体所公有,因此有必要实现一种基于类的特征,而不是基于实例对象的特征机制,这就是静态特征

## 成员修饰符的顺序
访问修饰符: public、private、protected、internal等

[特性] [修饰符] 核心声明  (方括号内的成分是可选的)
+ 修饰符(例如,访问修饰符: public、private 和 静态修饰符 static)
  + 如果有修饰符,必须放在核心声明之前
  + 如果有多个修饰符,可以任意顺序
+ 特性
  + 如果有特性,必须放在修饰符和核心声明之前
  + 如果有多个特性,可以任意顺序排列


## 实例类
### 实例类成员
> 实例成员: 成员被关联到一个实例。可以认为类的每个实例拥有自己的各个类成员的副本

::: tip
改变一个实例字段的值不会影响任何其他实例中成员的值
:::
```csharp
class D
{
  public int Mem1;
}

class Program
{
  static void Main()
  {
    D d1 = new D();
    D d2 = new D();
    d1.Mem1 = 10;
    d2.Mem1 = 28;
    Console.WriteLine($"d1={d1.Mem1},d2={d2.Mem1}"); // d1=10 d2=28
  }
}
```

## 静态类
> 静态类无法实例化(无法使用new运算符创建类类型的变量)。由于不存在任何实例变量,因此可以使用类名本身访问静态类成员。

与所有类类型的情况一样,加载引用该类的程序时,.NET运行时会加载静态类的类型信息。程序无法确切指定类加载的时间。但是,可保证进行加载,以及在程序中首次引用类之前初始化其字段并调用其静态构造函数。**静态构造函数只调用一次,在程序所驻留的应用程序域的生存期内,静态类会保留在内存中**。

静态类的功能:
+ 只包含静态成员(静态字段、静态属性、静态方法、静态构造函数)
+ 无法进行实例化
+ 会进行密封
+ 不能包含实例构造函数

::: tip
创建静态类基本上与创建只包含静态成员和私有构造函数的类相同。私有构造函数可防止类进行实例化。使用静态类的优点是编译器可以进行检查,以确保不会意外地添加任何实例成员。编译器可保证无法创建此类的实例
:::

> 静态类会进行密封,因此不能继承。它们不能继承自任何类(除了Object)
> 静态类可以包含静态构造函数


### 静态字段
+ 静态字段被类的所有实例共享,所有实例都访问同一内存位置
+ 可以使用static修饰符将字段声明为静态

**类的静态成员和实例成员分开保存**

```csharp
class D
{
  int Mem1;
  static int Mem2;
}

```
> 静态成员始终按类名(而不是实例名称)进行访问。静态成员只有一个副本存在(与创建的类的实例无关)。静态方法与属性无法在其包含类型中访问非静态字段和事件,它们无法访问任何对象的实例变量,除非在方法参数中显式传递它。

### 静态成员生存期
+ 实例对象创建之后产生实例成员,在实例销毁之后实例成员也就不存在了
+ 即使类没有实例,也存在静态成员,并且可以访问(在使用该类的任何静态成员之前初始化该成员,但不一定在程序执行的开始就初始化)

### 可以声明为静态成员
+ 数据成员(存储数据)
  + 字段
  + 类型
+ 函数成员(执行代码)
  + 方法
  + 属性
  + 构造函数
  + 运算符
  + 事件
  
## 静态类与非静态类总结
+ 静态类只能包含静态成员和静态方法,否则会抛出编译错误;而非静态类既可以包含非静态成员和非静态方法,也可以包含静态成员和静态方法。
+ 静态类不可实例化;非静态类可以实例化。不管是静态类还是非静态类,对静态成员和静态方法的调用都必须通过类来实现。
+ 如果一个类只包含静态成员和静态方法,应该将类标记为static,并提供私有的构造函数来避免实例创建,这其实是一种MonoState模式的体现。

## 静态构造函数与实例构造函数
> 静态构造函数,用于初始化类中的静态成员,包含静态字段和静态属性。静态构造函数不能带参数、不能有访问修饰符也不能被调用,通常由.NET运行库在第一次调用类成员之前执行。

+ 静态构造函数,可以和无参的实例构造函数同存。虽然参数列表相同,但是二者执行的时间不同,静态构造函数在运行库加载类时执行;而实例构造函数则在实例创建时执行。
+ 静态构造函数,只能对静态成员进行初始化操作,不能作用于非静态成员;而实例构造函数,可以初始化实例成员,也可以初始化静态成员,但是静态只读字段除外。
+ 静态构造函数只被执行一次,而且.NET运行库也无法确定静态构造函数什么时候被执行;而实例构造函数可以在多个实例创建时被执行多次。
+ 一个类只能有一个静态构造函数;而一个类可以有多个实例构造函数。
+ 静态字段的初始值,在静态构造函数调用之前被指定
+ 静态成员可以在声明时初始化,也可以通过静态构造函数进行初始化;这两种初始化都只能被执行一次。一般来说,简单的静态成员在声明时进行初始化即可,而复杂的静态成员则选择在静态构造函数中进行初始化较佳
+ 关于构造函数的执行顺序,大体上是按照下面的顺序的:
  + 分配静态成员的内存空间
  + 执行静态成员初始化
  + 执行静态构造函数
  + 分配对象实例的内存空间
  + 执行实例成员的初始化
  + 执行实例构造函数
+ 执行构造函数时,编译器会首先执行基类的构造函数,然后才执行子类的构造函数,并一次类推执行到System.Object类为止;同时,静态成员的内存分配、成员初始化和构造函数都只被执行一次,下一次创建对象实例时,只会执行实例成员的初始化过程。

## 静态成员与实例成员(静态字段和静态属性)
静态成员主要包括静态字段和静态属性。静态成员可以实现类中能够被所有实例对象共享数据。
+ 不需要在各个对象中重复同样的数据,从性能角度来说,静态成员可以避免不必要的数据冗余。
+ 静态成员提供了实现共享数据的有效机制,避免了以附加操作来处理每个对象都共享的数据信息。